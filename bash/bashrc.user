## Helper functions {{{
# source additional files with extension $2 in $1 {{{
function sourceFilesInDir {
local f
[ -d "$1" ] && \
	for f in "${1}"/*; do
		[ -f ${f} -a "x${f%$2}" != "x${f}" ] && . "${f}" # only source those with certain extension
	done
}
# }}}

# ANSI color codes {{{
function usecolor {
	use_color=false

	# Set colorful PS1 only on colorful terminals.
	# dircolors --print-database uses its own built-in database
	# instead of using /etc/DIR_COLORS.  Try to use the external file
	# first to take advantage of user additions.  Use internal bash
	# globbing instead of external grep binary.
	safe_term=${TERM//[^[:alnum:]]/?}   # sanitize TERM
	local match_lhs=""
	[[ -f ~/.dir_colors   ]] && match_lhs="${match_lhs}$(<~/.dir_colors)"
	[[ -f /etc/DIR_COLORS ]] && match_lhs="${match_lhs}$(</etc/DIR_COLORS)"
	[[ -z ${match_lhs}    ]] \
		&& type -P dircolors >/dev/null \
		&& match_lhs=$(dircolors --print-database)
	[[ $'\n'${match_lhs} == *$'\n'"TERM "${safe_term}* ]] && use_color=true

	if [[ $(uname) == "Darwin" ]] # OSX is not very nice...
 	then
		use_color=true
		export CLICOLOR=1
	fi
}

function loadANSIcolor {
	FGCBLK='[30m' # Black - Foreground
	FGCRED='[31m' # Red
	FGCGRN='[32m' # Green
	FGCYLW='[33m' # Yellow
	FGCBLU='[34m' # Blue
	FGCPUR='[35m' # Purple
	FGCCYN='[36m' # Cyan
	FGCWHT='[37m' # White
	BGCBLK='[40m' # Black - Background
	BGCRED='[41m' # Red
	BGCGRN='[42m' # Green
	BGCYLW='[43m' # Yellow
	BGCBLU='[44m' # Blue
	BGCPUR='[45m' # Purple
	BGCCYN='[46m' # Cyan
	BGCWHT='[47m' # White
	TXTRST='[0m'  # Text Reset
	TXTBLD='[1m'  # Bold type
	TXTUND='[4m'  # underline
	TXTINV='[7m'  # Revert fg and bg color
}
# }}}

# Path helper functions {{{
function pathremove () {
	local IFS=':'
	local NEWPATH
	local DIR
	local PATHVARIABLE=${2:-PATH}
	for DIR in ${!PATHVARIABLE} ; do
		if [ "$DIR" != "$1" ] ; then
			NEWPATH=${NEWPATH:+$NEWPATH:}$DIR
		fi
	done
	export $PATHVARIABLE="$NEWPATH"
}

function pathprepend () {
	pathremove $1 $2
	local PATHVARIABLE=${2:-PATH}
	export $PATHVARIABLE="$1${!PATHVARIABLE:+:${!PATHVARIABLE}}"
}

function pathappend () {
	pathremove $1 $2
	local PATHVARIABLE=${2:-PATH}
	export $PATHVARIABLE="${!PATHVARIABLE:+${!PATHVARIABLE}:}$1"
}
# }}}
## }}}

## Source enviornmental variables {{{
usrenvdir="${HOME}/.bashenv.d"
sourceFilesInDir ${usrenvdir} "*.env"
## }}}

## Interactive shell test {{{
# Test for an interactive shell.  There is no need to set anything
# past this point for scp and rcp, and it's important to refrain from
# outputting anything in those cases.
if [[ $- != *i* ]] ; then
	# Shell is non-interactive.  Be done now!
	return
fi
## }}}

## Enable ssh-agent and gpg-agent {{{
keychainbin=$(which keychain 2> /dev/null)
gpgagentbin=$(which gpg-agent 2> /dev/null)
if [ "x${keychainbin}" != "x" ]; then
	if [ "x${gpgagentbin}" != "x" ]; then
		eval `keychain --agents gpg --eval > /dev/null`;
	fi
	if [ -f "~/.ssh/id_dsa" ]; then
		alias ssh="eval \$(${keychainbin} --eval --agents ssh --quiet id_dsa) /usr/bin/ssh"
	fi
fi
#GPG_TTY=$(tty)
#export GPG_TTY
## }}}

## Colorful settings {{{
usecolor

if ${use_color}; then
	loadANSIcolor

	if [ ! ${EUID} = "0" ]; then
		PS1="\[$TXTBLD\]\[$FGCRED\]\h:\[$FGCPUR\]\W \[$FGCGRN\]\u\[$TXTRST\]\\$ "
	else
		PS1="\[$TXTBLD\]\[$FGCRED\]\u@\[$FGCPUR\]\h:\[$FGCGRN\]\W\[$TXTRST\] # "
	fi

	if ls --color >& /dev/null; then
		alias ls='ls --color=auto';
	else
		alias ls='ls -G';
	fi
else
	if [ ! ${EUID} = "0" ]; then
		PS1="\h:\W \u \\$";
	fi
fi

PS2="> $RS"
## }}}

## alias {{{
alias ll='ls -lh'
alias mv='mv -i'
alias rm='rm -i'
alias svi='sudo vi'
alias sshfs='sshfs -o follow_symlinks -o allow_root'

alias pdiff='diff -Naur'

alias rsync='rsync -e ssh'

# lpr:
alias lpr_n2='lpr -o number-up=2'
alias lpr_tsle='lpr -o sides=two-sided-long-edge'
alias lpr_tsle_n2='lpr_n2 -o sides=two-sided-long-edge'
alias lpr_tsse='lpr -o sides=two-sided-short-edge'
alias lpr_tsse_n2='lpr_n2 -o sides=two-sided-short-edge'

[ x`which matlab 2>/dev/null` != x ] && alias matlab='env XMODIFIERS="" matlab'
[ x`which mathematica 2>/dev/null` != x ] && alias mathematica='env XMODIFIERS="" mathematica'
[ x`which mid3v2 2>/dev/null` != x ] && alias id3v2='mid3v2'

if [ $UID -eq 0 ];
then
	# makes emerge nicer on IO
	alias emerge='ionice -c3 emerge'
fi

# Ubuntu-centric
pkgbin=`which apt-get 2> /dev/null`
if [ "x$pkgbin" != "x" ]; then
	alias apt-search='apt-cache search --names-only'
	alias apt-policy='apt-cache policy'
  alias apt-install='sudo apt-get install'
  alias apt-installs='sudo apt-get install --install-suggests'
  alias apt-remove='sudo apt-get remove'
  alias apt-purge='sudo apt-get remove --purge'
  alias apt-autoremove='sudo apt-get autoremove'
  alias apt-autopurge='sudo apt-get autoremove --purge'
  alias apt-update='sudo apt-get update'
  alias apt-upgrade='sudo apt-get upgrade'
  alias apt-distupgrade='sudo apt-get dist-upgrade'
	alias apt-build-dep='sudo apt-get build-dep'
fi

# Gentoo-centric
pkgbin=`which ebuild 2> /dev/null`
if [ "x$pkgbin" != "x" ]; then
	alias vmconf='sudo vi /etc/make.conf'
	alias vmuse='sudo vi /etc/make.use.conf'
	alias vpuse='sudo vi /etc/portage/package.use'
	alias vpkws='sudo vi /etc/portage/package.keywords'
	alias vpumsk='sudo vi /etc/portage/package.unmask'
	alias vpmsk='sudo vi /etc/portage/package.mask'
fi

# Arch-centric
pkgbin=`which pacman 2> /dev/null`
if [ "x$pkgbin" != "x" ]; then
	alias pacin='sudo pacman -S'            # Install specific package(s) from the repositories
	alias pacind='sudo pacman -S --asdeps'  # Install given package(s) as dependencies of another package
	alias pacins='sudo pacman -U'           # Install specific package not from the repositories but from a file 
	alias pacinsd='sudo pacman -U --asdeps' # Install specific package not from the repositories but from a file 
	alias pacre='sudo pacman -R'            # Remove the specified package(s), retaining its configuration(s) and required dependencies
	alias pacrem='sudo pacman -Rns'         # Remove the specified package(s), its configuration(s) and unneeded dependencies
	alias pacrep='pacman -Si'               # Display information about a given package in the repositories
	alias pacreps='pacman -Ss'              # Search for package(s) in the repositories
	alias pacloc='pacman -Qi'               # Display information about a given package in the local database
	alias paclocs='pacman -Qs'              # Search for package(s) in the local database
	#
	alias pacupg='sudo pacman -Syu'                 # Synchronize with repositories before upgrading packages that are out of date on the local system.
	alias pacmir='sudo pacman -Syy'                 # Force refresh of all package lists after updating /etc/pacman.d/mirrorlis
	alias pacupd='sudo pacman -Sy && sudo abs'      # Update and refresh the local package and ABS databases against repositories
	alias pacdepc='sudo pacman -Rs $(pacman -Qtdq)' # Clean all unneeded dependencies
fi

### }}}

## useful functions {{{
# use server/client mode for gvim
g() {
	if [ "x$1" = "x" ]
	then
		gvim > /dev/null 2>&1 &
	else
		if [ -z "`gvim --serverlist`" ]
		then
			printf "gvim $*\n"
			gvim $* > /dev/null 2>&1 &
		else
			printf "gvim --remote-silent $*\n"
			gvim --remote-silent $* 21> /dev/null
		fi
	fi 
}

# generates a random integer
random() {
	dd if=/dev/urandom count=1 2> /dev/null | cksum | cut -f1 -d" "
}

# generates random password
genpasswd() {
	local l=$1
	[ -z "$l" ] && l=20
	tr -dc A-Za-z0-9_ < /dev/urandom | head -c ${l} | xargs
}

genrandomwords() {
	local w=`egrep "^[a-z]{4,7}$" /usr/share/dict/words | wc -l`
	local c=5
	if [ ! "x$1" = "x" ]; then c="$1"; fi
	for i in `seq $c`; do
		egrep "^[a-z]{4,7}$" /usr/share/dict/words | sed -n "$((RANDOM % w + 1)) p"
	done
}

# update these to your favoite apps:
viewpdf() {
	epdfview "$1" >& /dev/null
}
#

# version string compare
# return 1 if $1 > $2
# return -1 if $2 > $1
# return 0 if equal
vercomp () {
	if [ x"$1" = x"$2" ]; then
		printf "0"; return
	fi

	local pre1=${1%%.*} pre2=${2%%.*}
	if [ "${pre1}" -gt "${pre2}" ]; then
		printf "1"; return 0;
	fi
	if [ "${pre1}" -lt "${pre2}" ]; then
		printf "2"; return 0;
	fi
	if [ "${pre1}" -eq "${pre2}" ]; then
		local post1=${1#${pre1}.} post2=${2#${pre2}.}
		b=`vercomp "${post1}" "${post2}"`
		printf "${b}"; return 0;
	fi
	return 1; # exit with error, usually due to non-numeric $1 or $2
}

# colorful man pages
man() {
	#export LESS_TERMCAP_mb=$'\E[01;31m'       # begin blinking
	#export LESS_TERMCAP_md=$'\E[01;38;5;74m'  # begin bold
	#export LESS_TERMCAP_me=$'\E[0m'           # end mode
	#export LESS_TERMCAP_se=$'\E[0m'           # end standout-mode
	#export LESS_TERMCAP_so=$'\E[38;5;246m'    # begin standout-mode - info box
	#export LESS_TERMCAP_ue=$'\E[0m'           # end underline
	#export LESS_TERMCAP_us=$'\E[04;38;5;146m' # begin underline
	env GROFF_NO_SGR=1 \
		LESS_TERMCAP_mb=$'\E[1;31;2m' \
		LESS_TERMCAP_md=$'\E[1;32m' \
		LESS_TERMCAP_me=$'\E[0m' \
		LESS_TERMCAP_us=$'\E[1;33m' \
		LESS_TERMCAP_ue=$'\E[0m' \
		LESS_TERMCAP_so=$'\E[1;34;7m' \
		LESS_TERMCAP_se=$'\E[0m' \
		man "$@"
}

# python helper
pyhelp() {
	pkg=${1}
	while [ -n "${pkg}" ]; do
		python -c "import ${pkg} as x; help(x)" && return
		if [ "x${pkg}" = "x${pkg%.*}" ]; then
		  return 1
		else
			pkg="${pkg%.*}";
			printf "Trying pkg ${pkg}\n" > /dev/stderr;
		fi
	done
}

pyenv_activate() {
	if [ ! -d "$1" ]; then
		VEPATH="${HOME}/.virtualenv/$1"
	else
		VEPATH="$1"
	fi
	if [ -d "$VEPATH" ]; then
		[ -f "${VEPATH}/bin/activate" ] && . ${VEPATH}/bin/activate
	else
		printf "$VEPATH is not a valid path.\n" && return 1
	fi
}
## }}}

### clean up {{{
for v in use_color pkgbin keychainbin
do
	unset $v
done
### }}}
## vim: foldmethod=marker ft=sh noet nosta ts=2 sw=2
