"" PATHOGEN {
filetype off
"call pathogen#incubate()
let g:pathogen_disabled = []
call add(g:pathogen_disabled, 'vim-snipmate')
call pathogen#infect('bundle/{}')
"call pathogen#helptags() "call this when installing new plugins
"call pathogen#infect()
filetype plugin indent on
""" } end pathogen

"" INCLUDES {
if filereadable(expand("$HOME/.vimrc.local"))
  so $HOME/.vimrc.local
elseif filereadable(expand("$HOME/_vimrc.local"))
  so $HOME/_vimrc.local
elseif filereadable(expand("$VIM/_vimrc.local"))
  so $VIM/_vimrc.local
endif
"" } end includes

"" BASIC OPTIONS {
set sw=4             " auto indent size
set ts=4             " tab size
set noet             " use space for tab
set nosta            " use sw for front tab, ts else
set sm               " show matching bracket
set ffs=unix,dos     " refers unix format

set nolz             " (lazyredraw) Don't update the display while executing macro
set showmode         " Show which mode you are in
set modeline         " Use modeline to customize setting
set wildmenu         " Enalbed enhanced command-line completion
set mousehide        " hide mouse cursor while typing
set shellslash       " (for windows) use \ for shell
set laststatus=2     " always put a status line in, even if there is only one window
set diffopt+=iwhite  " ignore white space
if exists("&cot")    " (version >= 7.2)
  set cot=longest,menu " complete option
en
set bs=2             " so that backspace works in Windows:

" my settings
" Set the status line the way I like it
function! SyntaxItem()
  return synIDattr(synID(line("."),col("."),1),"name")
endfunction
set stl=%f\ %m[%{&fileformat}]\ %r\ Line:\ %l/%L[%p%%]\ Col:\ %c[hi:%{SyntaxItem()}]\ Buf:\ #%n\ [%b][0x%B]
"" } end basic

"" KEYMAPS {
" Insert/Command mode motions {
" : These mapping remove the urge to use the page up/down, home, etc for movement
" : remap alt-* combo to actual key in terminal mode
" : In terminal mode, <M-x> defaults to <esc>+x, which exits insert mode.
set timeout timeoutlen=1000 ttimeoutlen=100
if !has("gui_running")
  if &term == "xterm"
    set <M-0>=0
    set <M-b>=b
    set <M-d>=d
    set <M-$>=$
    set <M-f>=f
    set <M-h>=h
    set <M-j>=j
    set <M-k>=k
    set <M-l>=l
  en
en
" use Meta-j/k is mapped to <Up>/<Down> can be used for pum
if has("gui_running") || &term == "xterm"
  no! <M-0> <Home>
  no! <M-b> <PageUp>
  no! <M-d> <Del>
  no! <M-$> <End>
  no! <M-f> <PageDown>
  no! <M-h> <Left>
  no! <M-j> <Down>
  no! <M-k> <Up>
  no! <M-l> <Right>
en

" right exist of insert mode:
ino <silent> <S-esc> <esc>l
"" }
" Buffer switch and kill {
" Create a new tab
nn <silent> ;nt :newtab 
" Go to previous buffer
nn <silent> ;j :bprevious<cr>
nn <silent> ;tj :tabp<cr>
" Go to next buffer
nn <silent> ;k :bnext<cr>
nn <silent> ;tk :tabN<cr>
" Delete current buffer
nn <silent> ;dc :bdelete<cr>
nn <silent> ;dc! :bdelete!<cr>
" }
" Window motion {
" Create a vertical split
nn <silent> ;wv :vs<cr>
" Close current window
nn <silent> ;wc :clo<cr>
" Move the cursor to the window left of the current one
no <silent> ;wh :wincmd h<cr>
" Move the cursor to the window below the current one
no <silent> ;wj :wincmd j<cr>
" Move the cursor to the window above the current one
no <silent> ;wk :wincmd k<cr>
" Move the cursor to the window right of the current one
no <silent> ;wl :wincmd l<cr>
" } window motion
" editing and sourcing {g}vimrc {
" edit .vimrc
nn <silent> ;ev :e $MYVIMRC<cr>
nn <silent> ;gev :e $MYGVIMRC<cr>
" source .vimrc
nn <silent> ;sv :so $MYVIMRC<cr>
nn <silent> ;gsv :so $MYGVIMRC<cr>
" } source {g}vimrc
" Save and Exit {
" Make me!!
nn <silent> ;mm :!make<cr>
" run last command
nn <silent> ;rr :!<Up><cr>
" write
nn <silent> ;vw :w<cr>
nn <silent> ;vwa :wa<cr>
" equivalent to ZZ:
nn <silent> ;vwq :wq<cr>
"nnoremap <silent> ;vw! :w!<cr>
" quite
nn <silent> ;vq :q<cr>
nn <silent> ;vqa :qa<cr>
nn <silent> ;vq! :q!<cr>
" }
" Miscellaneous {
" toggle paste mode
nn ;sp :set paste!<cr>:set paste?<cr>
" toggle highlighted search
nn ;sh :set invhls<cr>:set hls?<cr>
" toggle textwrap
nn ;sw :set wrap!<cr>:set wrap?<cr>
" retable entire file
nn ;rt :1,$retab<cr>
" cd to directory of current buffer
nn ;cd :lcd %:p:h<cr>
" display current directory
nn ;pwd :pwd<cr>
" } end misc
"" } end keymaps

"" COLOR SETTINGS {
"colo desert
" black background
if exists("syntax_on")
	syntax reset
endif
set background=dark
"set t_Co=256
let g:solarized_termtrans  = 1
"let g:solarized_visibility = 1
colorscheme solarized

" The main changes I make to the colours is make Function a tad brighter so
" it's more readable. Also, I prefer darkcyan for my comments. I don't
" like comments to be "louder" than the actual code.
" This is a hack of the clour section in
" /usr/share/vim/syntax/syntax.vim

hi Error ctermbg=Red ctermfg=White guibg=Red guifg=White cterm=reverse term=reverse
hi Todo ctermbg=Red ctermfg=Black guifg=Blue guibg=Yellow cterm=standout,bold term=standout
"hi Folded ctermbg=Yellow guibg=OrangeRed cterm=reverse
hi Normal cterm=none term=none
hi Function cterm=none term=none
hi Type cterm=none term=none
hi Statement cterm=bold term=none

if &background == "dark"
  " dark colors {
  hi Normal         ctermfg=White         guifg=White
  "hi Normal        cterm=none            term=none
  hi Comment        ctermfg=Cyan          guifg=Yellow      cterm=none         term=none
  "hi Constant       ctermfg=Magenta       guifg=Magenta     cterm=none         term=underline
  "hi String        ctermfg=Magenta       guifg=Magenta     cterm=underline    term=underline
  "hi Function      ctermfg=LightGreen    guifg=LightRed    term=bold
  hi Function       ctermfg=Yellow
  "hi Identifier    ctermfg=Cyan          guifg=#40ffff     cterm=bold         term=underline
  "hi Ignore        ctermfg=black
  "hi Operator       ctermfg=LightRed      guifg=Red
  "hi PreProc       ctermfg=LightRed      guifg=#ff80ff     cterm=bold
  "hi Repeat        ctermfg=White         guifg=LightRed    term=underline
  "hi Special       ctermfg=Red           guifg=LightRed    term=bold
  "hi Statement     ctermfg=White         cterm=bold        term=bold
  "hi Statement      ctermfg=Green         cterm=bold        term=bold
  "hi Type          ctermfg=LightGreen    guifg=#60ff60     gui=bold           cterm=bold        term=underline
  "hi Type           gui=bold              cterm=none        term=underline
  "hi Type          ctermfg=White         cterm=bold
  "hi Folded        ctermfg=White         guifg=Black
  hi Tab            ctermbg=LightBlue     guibg=grey30
  hi LeadSpace      ctermbg=DarkGray      guibg=grey15
  " }
else
  " bright colors {
  " hi Comment term=bold ctermfg=DarkBlue guifg=Blue
  " hi Constant term=underline ctermfg=DarkRed guifg=Magenta
  " hi Identifier term=underline ctermfg=DarkCyan guifg=DarkCyan
  " hi Ignore ctermfg=white guifg=bg
  " hi PreProc term=underline ctermfg=DarkMagenta guifg=Purple
  " hi Special term=bold ctermfg=DarkMagenta guifg=SlateBlue
  " hi Statement term=bold ctermfg=Brown guifg=Brown gui=bold
  " hi Type term=underline ctermfg=DarkGreen guifg=SeaGreen gui=bold
  " hi Folded ctermfg=White guifg=White
  hi Tab guibg=grey30 ctermbg=LightBlue
  hi LeadSpace guibg=grey15 ctermbg=LightGrey
  " }
endif
hi TrailSpace guibg=Red ctermbg=Red     

fu! AddMyMatches()
  let w:m1 = matchadd("LeadSpace", '^\zs \+\ze[^ ]') |
  let w:m2 = matchadd("TrailSpace", ' \+$') |
  let w:m3 = matchadd("Tab", '\t')
endf
call AddMyMatches()

" Common groups that link to default highlighting.
" You can specify other highlighting easily.
"hi link String Constant
"hi link Character Constant
"hi link Number Constant
"hi link Boolean Constant
"hi link Float Number
"hi link Conditional Statement
"hi link Label Statement
"hi link Keyword Statement
"hi link Exception Statement
"hi link Include PreProc
"hi link Define PreProc
"hi link Macro PreProc
"hi link PreCondit PreProc
"hi link StorageClass Type
"hi link Structure Type
"hi link Typedef Type
"hi link Tag Special
"hi link SpecialChar Special
"hi link Delimiter Special
"hi link SpecialComment Special
"hi link Debug Special
"hi link FoldColumn Folded

"" } end color

""  AUTOCOMMANDS {
"if has("autocmd")
"  " Enable file type detection, plugins, and indentation rules.
"  filetype plugin indent on
"
"  " reStructuredText (Python doctest) indent.
"  autocmd FileType rst setlocal sw=4 sts=4 et tw=72
"  " When editing a file, always jump to the last known cursor position.
"  autocmd BufReadPost *
"        \ if line("'\"") > 0 && line("'\"") <= line("$") |
"        \       execute "normal g`\"" |
"        \ endif
"endif
au VimEnter * au WinEnter * call AddMyMatches()

" GNUPLOT: identify by header {
au BufRead *.gp[ih]\=
      \  if getline(1) =~ '^#!.*\/gnuplot$' |
      \    set ft=gnuplot |
      \ endif
" }

" Customize treatment for TeX {
" : virtual wrap except for comment
" : swap between screen line file line motion
" : turn on spell checking
au FileType tex,plaintex setlocal tw=0 spell lbr wrap fo=cl sw=2 ts=2 |
      \nnoremap <buffer> gj j|
      \nnoremap <buffer> j gj|
      \nnoremap <buffer> gk k|
      \nnoremap <buffer> k gk
au FileType bib setlocal ts=2 sw=2 noet spell lbr
" }

" Python {
" : not extent tab, shiftwidth=tabstop=4
au FileType python,pyrex setlocal ts=4 sw=4 sts=4 sta fdm=indent |
			\ setlocal nosmartindent nocindent |
			\ let python_highlight_all = 1
" }

" File types text width{
"au FileType python,cpp setlocal tw=150
" }

" File types custom syntax settings {
au FileType cuda syntax keyword cType hfloat dfloat
" }

" File types that prefer expanded tabs {
au FileType sh,lisp,python,pyrex,cpp,cuda setlocal et

" File types that prefer indentation amount 2
au FileType vim,sh setlocal ts=4 sw=2 sts=2
" }

" File types folding issue {
au FileType vim,lua,sh setlocal fdm=marker
au FileType xml,cpp,cuda setlocal fdm=syntax

let javaScript_fold=1
" }

" text-like filetypes {
au FileType gitcommit setlocal tw=100 spell lbr wrap
" }
"" } end au

""" BUNDLES {
"virtualenv
let g:virtualenv_directory = '~/.virtualenv'

"syntastic
let g:syntastic_mode_map = { 'mode': 'active',
      \ 'active_filetypes': [],
      \ 'passive_filetypes': [] }

"snipmate
""" } end bundle

"" vim:fenc=utf-8 tw=80 sw=2 sts=2 et foldmethod=marker foldmarker={,} foldlevel=0
